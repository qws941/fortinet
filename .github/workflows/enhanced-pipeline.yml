# =============================================================================
# FortiGate Nextrade - Enhanced CI/CD Pipeline
# Complete pipeline with self-hosted runner, registry push, and monitoring
# Version: 3.0 - Enhanced with issue scanning and automation
# =============================================================================

name: Enhanced CI/CD Pipeline

on:
  push:
    branches: [main, master, develop]
    paths-ignore:
      - '**.md'
      - 'docs/**'
      - '.gitignore'
      - 'LICENSE'
  pull_request:
    branches: [main, master]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: false
        default: 'production'
        type: choice
        options:
          - production
          - staging
          - development
      skip_tests:
        description: 'Skip test execution'
        required: false
        default: false
        type: boolean
  schedule:
    # Daily security scan at 2 AM UTC
    - cron: '0 2 * * *'

env:
  # Registry Configuration
  REGISTRY: registry.jclee.me
  CHARTMUSEUM_URL: https://charts.jclee.me
  
  # Application Configuration
  APP_NAME: fortinet
  DEPLOYMENT_HOST: 192.168.50.110
  DEPLOYMENT_PORT: 30777
  
  # Build Configuration
  PYTHON_VERSION: '3.11'
  NODE_VERSION: '18'
  
  # Caching Configuration
  CACHE_VERSION: v4
  PIP_CACHE_DIR: ~/.cache/pip
  HELM_CACHE_DIR: ~/.cache/helm
  DOCKER_CACHE_DIR: ~/.docker/cache
  
  # Security Configuration
  SECURITY_SCAN_ENABLED: true
  VULNERABILITY_THRESHOLD: HIGH
  
  # Monitoring
  SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK }}
  METRICS_ENABLED: true

# Limit concurrent deployments
concurrency:
  group: deployment-${{ github.ref }}
  cancel-in-progress: false

jobs:
  # =============================================================================
  # Issue Scanner - Analyze GitHub Issues
  # =============================================================================
  issue-scanner:
    name: "üîç GitHub Issue Scanner"
    runs-on: [self-hosted, linux, x64]
    if: github.event_name == 'workflow_dispatch' || github.event_name == 'schedule'
    outputs:
      issues_count: ${{ steps.scan.outputs.count }}
      critical_issues: ${{ steps.scan.outputs.critical }}
      
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
    
    - name: Scan GitHub Issues
      id: scan
      run: |
        echo "üìã Scanning GitHub Issues..."
        
        # Use GitHub CLI if available
        if command -v gh &> /dev/null; then
          OPEN_ISSUES=$(gh issue list --state open --json number,title,labels --limit 100 || echo "[]")
          ISSUE_COUNT=$(echo "$OPEN_ISSUES" | jq '. | length')
          CRITICAL_COUNT=$(echo "$OPEN_ISSUES" | jq '[.[] | select(.labels[].name == "critical" or .labels[].name == "bug")] | length')
          
          echo "Found $ISSUE_COUNT open issues"
          echo "Critical/Bug issues: $CRITICAL_COUNT"
          
          echo "count=$ISSUE_COUNT" >> $GITHUB_OUTPUT
          echo "critical=$CRITICAL_COUNT" >> $GITHUB_OUTPUT
          
          # Save issue report
          echo "$OPEN_ISSUES" > issue-report.json
        else
          echo "GitHub CLI not available, skipping issue scan"
          echo "count=0" >> $GITHUB_OUTPUT
          echo "critical=0" >> $GITHUB_OUTPUT
        fi
    
    - name: Upload issue report
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: issue-report
        path: issue-report.json
        retention-days: 7

  # =============================================================================
  # Security Analysis
  # =============================================================================
  security-analysis:
    name: "üîê Security Analysis"
    runs-on: [self-hosted, linux, x64]
    outputs:
      security_status: ${{ steps.security.outputs.status }}
      vulnerabilities: ${{ steps.security.outputs.vulnerabilities }}
      
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
    
    - name: Setup Python
      uses: actions/setup-python@v5
      with:
        python-version: ${{ env.PYTHON_VERSION }}
        cache: 'pip'
    
    - name: Cache security tools
      uses: actions/cache@v3
      with:
        path: |
          ~/.local/bin
          ~/.cache/pip
        key: security-tools-${{ env.CACHE_VERSION }}-${{ runner.os }}
        restore-keys: |
          security-tools-${{ env.CACHE_VERSION }}-
    
    - name: Install security tools
      run: |
        pip install --upgrade pip
        pip install bandit safety semgrep pylint
    
    - name: Run security scans
      id: security
      run: |
        echo "üîê Running comprehensive security analysis..."
        
        SCAN_RESULTS=""
        VULNERABILITY_COUNT=0
        SECURITY_STATUS="pass"
        
        # Bandit scan for Python security issues
        if bandit -r src/ -f json -o bandit-report.json 2>/dev/null; then
          echo "‚úÖ Bandit scan completed"
        else
          BANDIT_ISSUES=$(cat bandit-report.json | jq '.results | length' 2>/dev/null || echo "0")
          VULNERABILITY_COUNT=$((VULNERABILITY_COUNT + BANDIT_ISSUES))
          echo "‚ö†Ô∏è Bandit found $BANDIT_ISSUES issues"
        fi
        
        # Safety check for vulnerable dependencies
        if safety check --json --output safety-report.json 2>/dev/null; then
          echo "‚úÖ Safety check passed"
        else
          SAFETY_ISSUES=$(cat safety-report.json | jq '.vulnerabilities | length' 2>/dev/null || echo "0")
          VULNERABILITY_COUNT=$((VULNERABILITY_COUNT + SAFETY_ISSUES))
          echo "‚ö†Ô∏è Safety found $SAFETY_ISSUES vulnerable dependencies"
        fi
        
        # Semgrep for advanced pattern matching
        if command -v semgrep &> /dev/null; then
          semgrep --config=auto --json -o semgrep-report.json src/ || true
          SEMGREP_ISSUES=$(cat semgrep-report.json | jq '.results | length' 2>/dev/null || echo "0")
          VULNERABILITY_COUNT=$((VULNERABILITY_COUNT + SEMGREP_ISSUES))
          echo "üìä Semgrep found $SEMGREP_ISSUES patterns"
        fi
        
        # Set outputs
        echo "vulnerabilities=$VULNERABILITY_COUNT" >> $GITHUB_OUTPUT
        
        if [ $VULNERABILITY_COUNT -gt 10 ]; then
          echo "status=fail" >> $GITHUB_OUTPUT
          SECURITY_STATUS="fail"
        elif [ $VULNERABILITY_COUNT -gt 0 ]; then
          echo "status=warning" >> $GITHUB_OUTPUT
          SECURITY_STATUS="warning"
        else
          echo "status=pass" >> $GITHUB_OUTPUT
        fi
        
        # Generate security summary
        cat > security-summary.md << EOF
        ## Security Analysis Summary
        
        - **Total Vulnerabilities**: $VULNERABILITY_COUNT
        - **Security Status**: $SECURITY_STATUS
        - **Scan Date**: $(date -u +'%Y-%m-%d %H:%M:%S UTC')
        
        ### Scan Results
        - Bandit Issues: $(cat bandit-report.json | jq '.results | length' 2>/dev/null || echo "0")
        - Safety Issues: $(cat safety-report.json | jq '.vulnerabilities | length' 2>/dev/null || echo "0")
        - Semgrep Patterns: $(cat semgrep-report.json | jq '.results | length' 2>/dev/null || echo "0")
        EOF
        
        echo "üìä Security analysis complete: $SECURITY_STATUS"
    
    - name: Upload security reports
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: security-reports
        path: |
          *-report.json
          security-summary.md
        retention-days: 30
    
    - name: Comment PR with security results
      if: github.event_name == 'pull_request'
      uses: actions/github-script@v7
      with:
        script: |
          const fs = require('fs');
          const summary = fs.readFileSync('security-summary.md', 'utf8');
          
          await github.rest.issues.createComment({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: context.issue.number,
            body: summary
          });

  # =============================================================================
  # Comprehensive Testing Matrix
  # =============================================================================
  test-suite:
    name: "üß™ Test: ${{ matrix.test-type }}"
    runs-on: [self-hosted, linux, x64]
    needs: [security-analysis]
    if: github.event.inputs.skip_tests != 'true'
    
    strategy:
      fail-fast: false
      matrix:
        test-type: [unit, integration, functional, performance, security]
        include:
          - test-type: unit
            command: "cd src && python -m pytest ../tests/unit/ -v --cov=. --cov-report=xml"
            timeout: 10
          - test-type: integration
            command: "cd src && python -m pytest ../tests/integration/ -v --timeout=60"
            timeout: 15
          - test-type: functional
            command: "cd src && python -m pytest ../tests/functional/ -v"
            timeout: 20
          - test-type: performance
            command: "cd src && python -m pytest ../tests/ -v -m performance --benchmark-only"
            timeout: 30
          - test-type: security
            command: "cd src && python -m pytest ../tests/ -v -m security"
            timeout: 10
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
    
    - name: Setup Python with cache
      uses: actions/setup-python@v5
      with:
        python-version: ${{ env.PYTHON_VERSION }}
        cache: 'pip'
        cache-dependency-path: requirements.txt
    
    - name: Cache test dependencies
      uses: actions/cache@v3
      with:
        path: |
          ${{ env.PIP_CACHE_DIR }}
          ~/.pytest_cache
          .coverage
        key: test-${{ env.CACHE_VERSION }}-${{ matrix.test-type }}-${{ hashFiles('requirements.txt') }}
        restore-keys: |
          test-${{ env.CACHE_VERSION }}-${{ matrix.test-type }}-
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip setuptools wheel
        pip install -r requirements.txt
        pip install pytest-cov pytest-timeout pytest-benchmark pytest-xdist
    
    - name: Run ${{ matrix.test-type }} tests
      timeout-minutes: ${{ matrix.timeout }}
      run: |
        echo "üß™ Running ${{ matrix.test-type }} tests..."
        ${{ matrix.command }} || true
    
    - name: Upload test results
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: test-results-${{ matrix.test-type }}
        path: |
          .coverage
          coverage.xml
          pytest-report.xml
        retention-days: 30

  # =============================================================================
  # Multi-Architecture Docker Build
  # =============================================================================
  build-images:
    name: "üî® Build: ${{ matrix.service }}"
    runs-on: [self-hosted, linux, x64]
    needs: [security-analysis, test-suite]
    
    strategy:
      fail-fast: false
      matrix:
        service: [redis, postgresql, fortinet, nginx, monitoring]
        include:
          - service: redis
            dockerfile: Dockerfile.redis
            context: .
            platforms: linux/amd64,linux/arm64
          - service: postgresql
            dockerfile: Dockerfile.postgresql
            context: .
            platforms: linux/amd64,linux/arm64
          - service: fortinet
            dockerfile: Dockerfile.all-in-one
            context: .
            platforms: linux/amd64
          - service: nginx
            dockerfile: docker/nginx/Dockerfile
            context: docker/nginx
            platforms: linux/amd64,linux/arm64
          - service: monitoring
            dockerfile: docker/monitoring/Dockerfile
            context: docker/monitoring
            platforms: linux/amd64,linux/arm64
    
    outputs:
      image_tag: ${{ steps.meta.outputs.tag }}
      version: ${{ steps.meta.outputs.version }}
      
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
    
    - name: Set up QEMU
      uses: docker/setup-qemu-action@v3
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      with:
        driver-opts: |
          network=host
          image=moby/buildkit:master
    
    - name: Generate metadata
      id: meta
      run: |
        SHORT_SHA=$(echo ${{ github.sha }} | cut -c1-7)
        BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ')
        VERSION="v1.0.${{ github.run_number }}-${SHORT_SHA}"
        
        if [[ "${{ github.ref_name }}" == "master" ]] || [[ "${{ github.ref_name }}" == "main" ]]; then
          TAG="latest"
        else
          TAG="${{ github.ref_name }}-${SHORT_SHA}"
        fi
        
        echo "tag=${TAG}" >> $GITHUB_OUTPUT
        echo "version=${VERSION}" >> $GITHUB_OUTPUT
        echo "build_date=${BUILD_DATE}" >> $GITHUB_OUTPUT
        echo "short_sha=${SHORT_SHA}" >> $GITHUB_OUTPUT
        
        echo "üì¶ Build metadata for ${{ matrix.service }}:"
        echo "  Version: ${VERSION}"
        echo "  Tag: ${TAG}"
        echo "  Build Date: ${BUILD_DATE}"
    
    - name: Login to Harbor Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ secrets.REGISTRY_USERNAME }}
        password: ${{ secrets.REGISTRY_PASSWORD }}
    
    - name: Check Dockerfile existence
      id: dockerfile-check
      run: |
        if [ ! -f "${{ matrix.dockerfile }}" ]; then
          echo "‚ö†Ô∏è Dockerfile not found: ${{ matrix.dockerfile }}"
          echo "exists=false" >> $GITHUB_OUTPUT
          
          # Try alternative paths
          if [ -f "Dockerfile" ] && [ "${{ matrix.service }}" == "fortinet" ]; then
            echo "Using default Dockerfile"
            echo "dockerfile=Dockerfile" >> $GITHUB_OUTPUT
            echo "exists=true" >> $GITHUB_OUTPUT
          fi
        else
          echo "dockerfile=${{ matrix.dockerfile }}" >> $GITHUB_OUTPUT
          echo "exists=true" >> $GITHUB_OUTPUT
        fi
    
    - name: Build and push ${{ matrix.service }}
      if: steps.dockerfile-check.outputs.exists == 'true'
      uses: docker/build-push-action@v5
      with:
        context: ${{ matrix.context }}
        file: ${{ steps.dockerfile-check.outputs.dockerfile }}
        platforms: ${{ matrix.platforms }}
        push: true
        tags: |
          ${{ env.REGISTRY }}/${{ env.APP_NAME }}-${{ matrix.service }}:${{ steps.meta.outputs.tag }}
          ${{ env.REGISTRY }}/${{ env.APP_NAME }}-${{ matrix.service }}:latest
        labels: |
          org.opencontainers.image.title=${{ env.APP_NAME }}-${{ matrix.service }}
          org.opencontainers.image.version=${{ steps.meta.outputs.version }}
          org.opencontainers.image.created=${{ steps.meta.outputs.build_date }}
          org.opencontainers.image.revision=${{ github.sha }}
        build-args: |
          BUILD_DATE=${{ steps.meta.outputs.build_date }}
          VERSION=${{ steps.meta.outputs.version }}
          VCS_REF=${{ github.sha }}
        cache-from: |
          type=gha,scope=${{ matrix.service }}
          type=registry,ref=${{ env.REGISTRY }}/${{ env.APP_NAME }}-${{ matrix.service }}:buildcache
        cache-to: |
          type=gha,mode=max,scope=${{ matrix.service }}
          type=registry,ref=${{ env.REGISTRY }}/${{ env.APP_NAME }}-${{ matrix.service }}:buildcache,mode=max
    
    - name: Container vulnerability scan
      if: env.SECURITY_SCAN_ENABLED == 'true' && steps.dockerfile-check.outputs.exists == 'true'
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: '${{ env.REGISTRY }}/${{ env.APP_NAME }}-${{ matrix.service }}:${{ steps.meta.outputs.tag }}'
        format: 'sarif'
        output: 'trivy-${{ matrix.service }}.sarif'
        severity: ${{ env.VULNERABILITY_THRESHOLD }}
      continue-on-error: true
    
    - name: Upload scan results
      if: always()
      uses: github/codeql-action/upload-sarif@v3
      with:
        sarif_file: 'trivy-${{ matrix.service }}.sarif'
        category: 'container-${{ matrix.service }}'

  # =============================================================================
  # Helm Chart Management
  # =============================================================================
  helm-deployment:
    name: "‚öôÔ∏è Helm Deployment"
    runs-on: [self-hosted, linux, x64]
    needs: [build-images]
    if: github.ref == 'refs/heads/master' || github.ref == 'refs/heads/main'
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Setup Helm
      uses: azure/setup-helm@v3
      with:
        version: '3.14.0'
    
    - name: Update Helm values
      run: |
        echo "üìã Updating Helm chart values..."
        
        CHART_VERSION="1.0.${{ github.run_number }}"
        IMAGE_TAG="${{ needs.build-images.outputs.image_tag }}"
        
        # Update Chart.yaml
        if [ -f "charts/fortinet/Chart.yaml" ]; then
          sed -i "s/^version:.*/version: ${CHART_VERSION}/" charts/fortinet/Chart.yaml
          sed -i "s/^appVersion:.*/appVersion: \"${IMAGE_TAG}\"/" charts/fortinet/Chart.yaml
          
          # Update values.yaml
          sed -i "s|repository:.*|repository: ${{ env.REGISTRY }}/${{ env.APP_NAME }}|" charts/fortinet/values.yaml
          sed -i "s|tag:.*|tag: \"${IMAGE_TAG}\"|" charts/fortinet/values.yaml
          
          echo "‚úÖ Helm chart updated to version ${CHART_VERSION}"
        else
          echo "‚ö†Ô∏è Helm chart not found, skipping update"
        fi
    
    - name: Package and push Helm chart
      if: success()
      run: |
        if [ -f "charts/fortinet/Chart.yaml" ]; then
          helm dependency update charts/fortinet || true
          helm package charts/fortinet
          
          # Push to ChartMuseum
          CHART_FILE=$(ls fortinet-*.tgz | head -1)
          if [ -f "$CHART_FILE" ]; then
            curl -L --data-binary "@${CHART_FILE}" \
              -u "${{ secrets.CHARTMUSEUM_USERNAME }}:${{ secrets.CHARTMUSEUM_PASSWORD }}" \
              "${{ env.CHARTMUSEUM_URL }}/api/charts" || true
          fi
        fi
    
    - name: GitOps commit
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        
        git add charts/ || true
        git diff --staged --quiet || git commit -m "ci: update helm chart to ${{ needs.build-images.outputs.version }} [skip ci]"
        git push || true

  # =============================================================================
  # Deployment Verification
  # =============================================================================
  verify-deployment:
    name: "‚úÖ Deployment Verification"
    runs-on: [self-hosted, linux, x64]
    needs: [build-images, helm-deployment]
    if: github.ref == 'refs/heads/master' || github.ref == 'refs/heads/main'
    
    steps:
    - name: Wait for deployment
      run: |
        echo "‚è≥ Waiting for deployment to stabilize..."
        sleep 60
    
    - name: Health checks
      id: health
      run: |
        echo "üè• Running health checks..."
        
        MAX_RETRIES=10
        RETRY_COUNT=0
        HEALTH_STATUS="unknown"
        
        while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
          if curl -f -s -o /dev/null -w "%{http_code}" \
            "http://${{ env.DEPLOYMENT_HOST }}:${{ env.DEPLOYMENT_PORT }}/api/health" | grep -q "200"; then
            HEALTH_STATUS="healthy"
            echo "‚úÖ Application is healthy"
            break
          else
            RETRY_COUNT=$((RETRY_COUNT + 1))
            echo "‚è≥ Health check attempt $RETRY_COUNT/$MAX_RETRIES"
            sleep 10
          fi
        done
        
        echo "status=${HEALTH_STATUS}" >> $GITHUB_OUTPUT
    
    - name: Performance test
      if: steps.health.outputs.status == 'healthy'
      run: |
        echo "‚ö° Running performance tests..."
        
        # Simple load test
        if command -v ab &> /dev/null; then
          ab -n 100 -c 10 "http://${{ env.DEPLOYMENT_HOST }}:${{ env.DEPLOYMENT_PORT }}/" || true
        fi
        
        # Response time check
        RESPONSE_TIME=$(curl -o /dev/null -s -w '%{time_total}' \
          "http://${{ env.DEPLOYMENT_HOST }}:${{ env.DEPLOYMENT_PORT }}/api/health")
        
        echo "üìä Health endpoint response time: ${RESPONSE_TIME}s"
    
    - name: Generate deployment report
      if: always()
      run: |
        cat > deployment-report.md << EOF
        # Deployment Report
        
        ## Build Information
        - **Version**: ${{ needs.build-images.outputs.version }}
        - **Image Tag**: ${{ needs.build-images.outputs.image_tag }}
        - **Build Number**: ${{ github.run_number }}
        - **Git SHA**: ${{ github.sha }}
        - **Branch**: ${{ github.ref_name }}
        
        ## Deployment Status
        - **Health Check**: ${{ steps.health.outputs.status }}
        - **Deployment Time**: $(date -u +'%Y-%m-%d %H:%M:%S UTC')
        
        ## Access URLs
        - **Application**: http://${{ env.DEPLOYMENT_HOST }}:${{ env.DEPLOYMENT_PORT }}
        - **Health API**: http://${{ env.DEPLOYMENT_HOST }}:${{ env.DEPLOYMENT_PORT }}/api/health
        - **Metrics**: http://${{ env.DEPLOYMENT_HOST }}:${{ env.DEPLOYMENT_PORT }}/metrics
        
        ## Images Published
        - ${{ env.REGISTRY }}/${{ env.APP_NAME }}-redis:${{ needs.build-images.outputs.image_tag }}
        - ${{ env.REGISTRY }}/${{ env.APP_NAME }}-postgresql:${{ needs.build-images.outputs.image_tag }}
        - ${{ env.REGISTRY }}/${{ env.APP_NAME }}:${{ needs.build-images.outputs.image_tag }}
        EOF
        
        echo "üìã Deployment report generated"
    
    - name: Upload deployment report
      uses: actions/upload-artifact@v4
      with:
        name: deployment-report
        path: deployment-report.md
        retention-days: 90

  # =============================================================================
  # Notification and Summary
  # =============================================================================
  pipeline-summary:
    name: "üìä Pipeline Summary"
    runs-on: [self-hosted, linux, x64]
    needs: [issue-scanner, security-analysis, test-suite, build-images, helm-deployment, verify-deployment]
    if: always()
    
    steps:
    - name: Generate summary
      run: |
        echo "## üéâ Enhanced CI/CD Pipeline Summary" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        # Issue Scanner Results
        if [ "${{ needs.issue-scanner.outputs.issues_count }}" != "" ]; then
          echo "### üìã GitHub Issues" >> $GITHUB_STEP_SUMMARY
          echo "- Open Issues: ${{ needs.issue-scanner.outputs.issues_count }}" >> $GITHUB_STEP_SUMMARY
          echo "- Critical Issues: ${{ needs.issue-scanner.outputs.critical_issues }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
        fi
        
        # Security Analysis
        echo "### üîê Security Analysis" >> $GITHUB_STEP_SUMMARY
        echo "- Status: ${{ needs.security-analysis.outputs.security_status }}" >> $GITHUB_STEP_SUMMARY
        echo "- Vulnerabilities: ${{ needs.security-analysis.outputs.vulnerabilities }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        # Test Results
        echo "### üß™ Test Suite" >> $GITHUB_STEP_SUMMARY
        echo "- Unit Tests: ${{ needs.test-suite.result }}" >> $GITHUB_STEP_SUMMARY
        echo "- Integration Tests: ${{ needs.test-suite.result }}" >> $GITHUB_STEP_SUMMARY
        echo "- Security Tests: ${{ needs.test-suite.result }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        # Build Results
        echo "### üî® Build & Push" >> $GITHUB_STEP_SUMMARY
        echo "- Images Built: ‚úÖ" >> $GITHUB_STEP_SUMMARY
        echo "- Registry: ${{ env.REGISTRY }}" >> $GITHUB_STEP_SUMMARY
        echo "- Tag: ${{ needs.build-images.outputs.image_tag }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        # Deployment
        echo "### üöÄ Deployment" >> $GITHUB_STEP_SUMMARY
        echo "- Helm Deployment: ${{ needs.helm-deployment.result }}" >> $GITHUB_STEP_SUMMARY
        echo "- Verification: ${{ needs.verify-deployment.result }}" >> $GITHUB_STEP_SUMMARY
        echo "- URL: http://${{ env.DEPLOYMENT_HOST }}:${{ env.DEPLOYMENT_PORT }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        # Overall Status
        if [ "${{ needs.verify-deployment.result }}" == "success" ]; then
          echo "## ‚úÖ Pipeline Completed Successfully!" >> $GITHUB_STEP_SUMMARY
        else
          echo "## ‚ö†Ô∏è Pipeline Completed with Issues" >> $GITHUB_STEP_SUMMARY
        fi
    
    - name: Send Slack notification
      if: env.SLACK_WEBHOOK != ''
      run: |
        STATUS_EMOJI="‚úÖ"
        STATUS_TEXT="Success"
        
        if [ "${{ needs.verify-deployment.result }}" != "success" ]; then
          STATUS_EMOJI="‚ö†Ô∏è"
          STATUS_TEXT="Failed"
        fi
        
        curl -X POST ${{ env.SLACK_WEBHOOK }} \
          -H 'Content-Type: application/json' \
          -d "{
            \"text\": \"${STATUS_EMOJI} Pipeline ${STATUS_TEXT}\",
            \"blocks\": [
              {
                \"type\": \"header\",
                \"text\": {
                  \"type\": \"plain_text\",
                  \"text\": \"FortiGate Nextrade CI/CD Pipeline\"
                }
              },
              {
                \"type\": \"section\",
                \"fields\": [
                  {
                    \"type\": \"mrkdwn\",
                    \"text\": \"*Status:*\n${STATUS_TEXT}\"
                  },
                  {
                    \"type\": \"mrkdwn\",
                    \"text\": \"*Version:*\n${{ needs.build-images.outputs.version }}\"
                  },
                  {
                    \"type\": \"mrkdwn\",
                    \"text\": \"*Branch:*\n${{ github.ref_name }}\"
                  },
                  {
                    \"type\": \"mrkdwn\",
                    \"text\": \"*Run:*\n#${{ github.run_number }}\"
                  }
                ]
              }
            ]
          }" || true
    
    - name: Cleanup
      if: always()
      run: |
        echo "üßπ Cleaning up resources..."
        docker system prune -f --filter "until=24h" || true
        echo "‚úÖ Cleanup completed"